[id="calling_invoking"]

= Calling and Invoking Contracts

Let's interact with our deployed voting contract.

* Calling contracts refer to interacting with contract functions with the `@view` entry point (decorator). Since we are not altering the state of the network, we do not need to pay fees and we do not need to sign the operation.
* Invoking contracts is interacting with contract functions with the `@external` entry point. We need to sign the transaction and pay the operation fee.

Here is the command that we used, to deploy the contract. Note that the voter accounts registered during deployment are the only ones that can vote.

[source, bash]
----
starknet deploy --class_hash 0x3853a0a2697a834f808decbfcc01dc103d76bdcf2684975decf0793e4af896a --inputs 0x072c49c0f3a76640855c6d56104b034f2a61b95da5eb1c1a6afb8f7277856220 0x03de621c797439d2a5859c6cdebf3487ab84aa981e29a0e7fc0db455adab23d5 0x05c5b5acd90b327e45bf0076d52edfc4186d7e289c100625f630a53cee8cd57b --account vote_admin --max_fee 100000000000000000
----

== Checking for the ability to vote

Before we start voting, we have the ability to check if a particular address/user can vote or not. There are two functions that are doing this check in the given contract: +

[source,rust]
----
#[view]
fn voter_can_vote(user_address: ContractAddress) -> bool {
    // Read the voting status of the user from storage
    can_vote::read(user_address)
}
----

[source,rust]
----
#[view]
fn is_voter_registered(address: ContractAddress) -> bool {
    // Read the registration status of the address from storage
    registered_voter::read(address)
}
----

Both of the above functions are _view_ functions and therefore, we can use the _starknet call_ syntax to get the values from these functions. Let's use them alternatively to check the ability of the 3 voters to vote.

You can directly pass the function name and the contract address in the _call_ syntax along with inputs(if any) to call a [#view] function. 

[source, bash]
----
starknet call --function voter_can_vote --inputs 0x072c49c0f3a76640855c6d56104b034f2a61b95da5eb1c1a6afb8f7277856220 --address 0x06ce0bdf1985308cbb800364385ac66cbae203688e3e28f3b1c234da62a754bf --account vote_admin
1 //CLI Output
----

We have passed one of the registered voter addresses(voter_1) as an input to this function and therefore, we got the result 1(boolean true) printed on the CLI.

Let us try to call the _is_voter_registered_ function with an account that's not registered and observe the result.

[source, bash]
----
starknet call --function is_voter_registered --inputs 0x0265a5a55cd3b03c2a3519f9b7a796a2c770fc9f85538df1e27f268f2885a616 --address 0x06ce0bdf1985308cbb800364385ac66cbae203688e3e28f3b1c234da62a754bf --account vote_admin
0 //CLI Output
----

You can see that with the wrong account address, the terminal output is 0 i.e false.

*FUN ASSIGNMENT:* Before voting, make sure to check that all the 3 voter accounts are registered and able to vote!

== Let's vote

Now that we have cross verified the ability of the voter accounts to vote, let's vote!

If you observe the code snippet of the function below, the function takes a u8 as argument to vote. As per the comments in the code, if we send a 0, we are voting *No* for the proposal associated with this contract and if we send a 1, we are voting *Yes*.

[source,rust]
----
#[external]
fn vote(vote: u8) {
    ...//Voting logic
}
----

Since this function changes the state of the variables associated with the contract, we need to perform a _starknet invoke_ to add the value of our vote.

The syntax of invoke is similar to call but in this case, we will be sending the input as either 1/0. Remember that only a registered voter can vote, so you will have to change the account to reflect one of the voter accounts.

[source, bash]
----
//Voting Yes
starknet invoke --function vote --address 0x06ce0bdf1985308cbb800364385ac66cbae203688e3e28f3b1c234da62a754bf --inputs 1 --account voter_2

//Voting No
starknet invoke --function vote --address 0x06ce0bdf1985308cbb800364385ac66cbae203688e3e28f3b1c234da62a754bf --inputs 0 --account voter_3
----

You can vote using the voter_1 account before moving to the next step, which is calculating the results.

== What are the results?

In order to calculate the results, we have a simple function called _get_vote_results_. This is a [#view] function, so we need to use the _starknet call_ command to call this function and see the results for ourselves.

[source, bash]
----
//Voting Yes
starknet call --function get_vote_results --address 0x06ce0bdf1985308cbb800364385ac66cbae203688e3e28f3b1c234da62a754bf --account vote_admin

//Example output if one voted Yes
1 0 100 0

//Example output if 2 votes Yes and 1 voted No
2 1 66 33
----

Based on what you voted as voter_1, you are able to see 4 values on your screen - number of yes, number of nos, percentage of yes, percentage of no.

And viola! You have deployed and interacted with the voting smart contract on Starknet! 

== Contributing

[quote, The Starknet Community]
____
*Unleash Your Passion to Perfect StarkNetBook*

StarkNetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others.

Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our https://github.com/starknet-edu/starknetbook/blob/main/CONTRIBUTING.adoc[guidelines] and join our vibrant community. Let's fearlessly build Starknet! 
____

